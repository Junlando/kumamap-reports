<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>クマ出没マップ｜過去7日出没情報</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="日本全国のクマ過去7日出没情報を確認できるクマ出没マップの週間レポート。都道府県別の件数と日次推移を可視化しています。"
  />
  <style>
    :root {
      --ink: #0f172a;
      --ink-soft: #475569;
      --accent: #b91c1c;
      --border: #e2e8f0;
      --bg: #ffffff;
      --bg-muted: #f8fafc;
      --bar: #0b1220;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--ink);
      min-height: 100vh;
      line-height: 1.6;
    }

    a {
      color: inherit;
      text-decoration: none;
    }

    .page {
      max-width: 1080px;
      margin: 0 auto;
      padding: 32px 18px 64px;
    }

    header {
      border-bottom: 2px solid var(--border);
      padding-bottom: 18px;
      margin-bottom: 32px;
    }

    .headline {
      font-size: 32px;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .headline strong {
      color: var(--accent);
    }

    .meta-row {
      margin-top: 12px;
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
      font-size: 14px;
      color: var(--ink-soft);
    }

    .summary-strip {
      margin-top: 18px;
      padding: 12px 16px;
      background: var(--bg-muted);
      border-left: 4px solid var(--accent);
      font-size: 15px;
    }

    #total-count {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent);
    }

    .report-content {
      display: flex;
      flex-direction: column;
      gap: 32px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      padding: 24px;
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.04);
    }

    .card h2 {
      font-size: 20px;
      margin-bottom: 4px;
    }

    .card p.subhead {
      font-size: 14px;
      color: var(--ink-soft);
      margin-bottom: 18px;
    }

    .timeline-chart {
      position: relative;
      width: 100%;
      padding: 12px;
      background: #f5f7fb;
      border-radius: 16px;
    }

    .timeline-chart svg {
      width: 100%;
      height: 260px;
    }

    .area-fill {
      fill: url(#timelineGradient);
    }

    .area-line {
      fill: none;
      stroke: var(--bar);
      stroke-width: 3;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .area-point {
      fill: #fff;
      stroke: var(--bar);
      stroke-width: 2;
    }

    .grid-line {
      stroke: rgba(15, 23, 42, 0.08);
      stroke-width: 1;
    }

    .grid-label {
      font-size: 11px;
      fill: var(--ink-soft);
    }

    .axis-labels {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--ink-soft);
      margin-top: 12px;
    }

    .timeline-status {
      margin-top: 12px;
      font-size: 13px;
      color: var(--ink-soft);
    }

    .pref-summary h2 {
      font-size: 18px;
      margin-bottom: 12px;
      border-left: 4px solid var(--accent);
      padding-left: 10px;
    }

    .pref-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(190px, 1fr));
      gap: 10px;
      list-style: none;
      font-size: 14px;
    }

    .pref-list li {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg-muted);
      padding: 10px 12px;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .pref-list li:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
    }

    .pref-link {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      gap: 8px;
    }

    .pref-name {
      font-weight: 600;
    }

    .pref-count {
      font-weight: 700;
      color: var(--accent);
    }

    footer {
      margin-top: 48px;
      font-size: 12px;
      color: var(--ink-soft);
      text-align: right;
    }

    @media (max-width: 600px) {
      .headline {
        font-size: 26px;
      }

      .timeline-chart {
        gap: 8px;
      }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <div class="headline">
        国内クマ過去七日出没情報 <strong id="report-date"></strong>
      </div>
      <div class="meta-row">
        <span>更新: <span id="update-time">-</span></span>
        <span>データ提供: クマ出没マップ</span>
      </div>
      <div class="summary-strip">
        現在把握している出没件数 <span id="total-count">0件</span>
      </div>
    </header>

    <section class="report-content">
      <div class="card">
        <h2>Daily Activity Timeline</h2>
        <p class="subhead">過去7日間の出没件数推移</p>
        <div id="timeline-chart" class="timeline-chart" aria-live="polite"></div>
        <div id="timeline-status" class="timeline-status">データを集計中です…</div>
      </div>

      <div class="card pref-summary">
        <h2>都道府県別の出没状況（過去7日）</h2>
        <ul id="prefecture-summary" class="pref-list">
          <li>データ読み込み中…</li>
        </ul>
      </div>
    </section>

    <footer>
      非公式ツールです。正確な情報は各自治体・警察の公式発表をご確認ください。
    </footer>
  </div>

  <script>
    // ================================
    // 全域變數
    // ================================
    const timelineEl = document.getElementById("timeline-chart");
    const timelineStatusEl = document.getElementById("timeline-status");
    const prefSummaryEl = document.getElementById("prefecture-summary");
    const reportDateEl = document.getElementById("report-date");
    const updateTimeEl = document.getElementById("update-time");
    const totalCountEl = document.getElementById("total-count");

    const PREF_MAP = [
      { id: "hokkaido", name: "北海道" },
      { id: "aomori", name: "青森県" },
      { id: "iwate", name: "岩手県" },
      { id: "miyagi", name: "宮城県" },
      { id: "akita", name: "秋田県" },
      { id: "yamagata", name: "山形県" },
      { id: "fukushima", name: "福島県" },
      { id: "ibaraki", name: "茨城県" },
      { id: "tochigi", name: "栃木県" },
      { id: "gunma", name: "群馬県" },
      { id: "saitama", name: "埼玉県" },
      { id: "chiba", name: "千葉県" },
      { id: "tokyo", name: "東京都" },
      { id: "kanagawa", name: "神奈川県" },
      { id: "niigata", name: "新潟県" },
      { id: "toyama", name: "富山県" },
      { id: "ishikawa", name: "石川県" },
      { id: "fukui", name: "福井県" },
      { id: "yamanashi", name: "山梨県" },
      { id: "nagano", name: "長野県" },
      { id: "gifu", name: "岐阜県" },
      { id: "shizuoka", name: "静岡県" },
      { id: "aichi", name: "愛知県" },
      { id: "mie", name: "三重県" },
      { id: "shiga", name: "滋賀県" },
      { id: "kyoto", name: "京都府" },
      { id: "osaka", name: "大阪府" },
      { id: "hyogo", name: "兵庫県" },
      { id: "nara", name: "奈良県" },
      { id: "wakayama", name: "和歌山県" },
      { id: "tottori", name: "鳥取県" },
      { id: "shimane", name: "島根県" },
      { id: "okayama", name: "岡山県" },
      { id: "hiroshima", name: "広島県" },
      { id: "yamaguchi", name: "山口県" },
      { id: "tokushima", name: "徳島県" },
      { id: "kagawa", name: "香川県" },
      { id: "ehime", name: "愛媛県" },
      { id: "kochi", name: "高知県" },
      { id: "fukuoka", name: "福岡県" },
      { id: "saga", name: "佐賀県" },
      { id: "nagasaki", name: "長崎県" },
      { id: "kumamoto", name: "熊本県" },
      { id: "oita", name: "大分県" },
      { id: "miyazaki", name: "宮崎県" },
      { id: "kagoshima", name: "鹿児島県" },
      { id: "okinawa", name: "沖縄県" },
    ];

    const PREF_ALIASES = {
      shimanetottori: "島根県",
      narakizugawa: "京都府",
    };

    const PREF_REMAP = {
      shimanetottori: "shimane",
      narakizugawa: "kyoto",
    };

    const JST_OFFSET_MS = 9 * 60 * 60 * 1000;
    const API_BASE = "https://kumamap.ngrok.app/incidents/";
    const RANGE_DAYS = 7;
    const DAY_SECONDS = 24 * 60 * 60;
    const DATA_JSON_PATH = "./data.json";

    function parseTimestamp(tsSeconds) {
      if (!tsSeconds) return null;
      const num = Number(tsSeconds);
      if (!Number.isFinite(num)) return null;
      const d = new Date(num * 1000);
      return isNaN(d.getTime()) ? null : d;
    }

    function formatHeadlineDate(date) {
      if (!date) return "-";
      const utcMs = date.getTime();
      const jstMs = utcMs + JST_OFFSET_MS;
      const jstDate = new Date(jstMs);
      const m = jstDate.getUTCMonth() + 1;
      const d = jstDate.getUTCDate();
      return `${m}月${d}日`;
    }

    function formatFullDateTime(date) {
      if (!date) return "-";
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const dd = String(date.getDate()).padStart(2, "0");
      const hh = String(date.getHours()).padStart(2, "0");
      const mi = String(date.getMinutes()).padStart(2, "0");
      return `${yyyy}/${mm}/${dd} ${hh}:${mi}`;
    }

    function getPrefName(prefId) {
      const normalized = (prefId || "").toLowerCase();
      if (PREF_ALIASES[normalized]) {
        return PREF_ALIASES[normalized];
      }
      return (
        PREF_MAP.find((p) => p.id === normalized)?.name ||
        prefId ||
        "不明"
      );
    }

    function getHeadlineDateOverride() {
      return null;
    }

    function getJstMidnightUtcMs(date) {
      const jstDate = new Date(date.getTime() + JST_OFFSET_MS);
      const year = jstDate.getUTCFullYear();
      const month = jstDate.getUTCMonth();
      const dom = jstDate.getUTCDate();
      return Date.UTC(year, month, dom) - JST_OFFSET_MS;
    }

    function getWeeklyRange() {
      const now = new Date();
      const todayMidnightUtcMs = getJstMidnightUtcMs(now);
      const beforeSeconds = Math.floor(todayMidnightUtcMs / 1000);
      const afterUtcMs = todayMidnightUtcMs - RANGE_DAYS * DAY_SECONDS * 1000;
      const afterSeconds = Math.floor(afterUtcMs / 1000);
      const startLabelDate = new Date(afterUtcMs);
      const endLabelDate = new Date(todayMidnightUtcMs - 1000);
      return { afterSeconds, beforeSeconds, startLabelDate, endLabelDate, startUtcMs: afterUtcMs };
    }

    const WEEKLY_RANGE = getWeeklyRange();

    function buildApiUrl() {
      const { afterSeconds, beforeSeconds } = WEEKLY_RANGE;
      const query = new URLSearchParams();
      query.set("created_after", afterSeconds);
      query.set("created_before", beforeSeconds);
      return `${API_BASE}?${query.toString()}`;
    }

    function getRangeLabel() {
      const override = getHeadlineDateOverride();
      if (override) {
        return `${formatHeadlineDate(override)}～${formatHeadlineDate(override)}`;
      }
      const { startLabelDate, endLabelDate } = WEEKLY_RANGE;
      return `${formatHeadlineDate(startLabelDate)}～${formatHeadlineDate(endLabelDate)}`;
    }

    function buildPrefSummary(items) {
      const counts = new Map();
      items.forEach((item) => {
        const id = (item.prefecture || "").toLowerCase();
        if (!id) return;
        const name = getPrefName(id);
        counts.set(id, { id, name, count: (counts.get(id)?.count || 0) + 1 });
      });
      return Array.from(counts.values()).sort(
        (a, b) => b.count - a.count || a.name.localeCompare(b.name)
      );
    }

    function renderPrefSummary(summary) {
      if (!summary || summary.length === 0) {
        prefSummaryEl.innerHTML =
          "<li>現在表示できる出没情報はありません。</li>";
        return;
      }
      prefSummaryEl.innerHTML = summary
        .map((item) => {
          const afterSec = WEEKLY_RANGE.afterSeconds;
          const beforeSec = WEEKLY_RANGE.beforeSeconds;
          const query = new URLSearchParams();
          if (afterSec) query.set("created_after", afterSec);
          if (beforeSec) query.set("created_before", beforeSec);
          const targetPath = `https://junlando.com/kumamap/dailyreport/${item.id}/`;
          const qs = query.toString();
          const url = `${targetPath}${qs ? `?${qs}` : ""}`;
          return `
            <li>
              <a class="pref-link" href="${url}">
                <span class="pref-name">${item.name}</span>
                <span class="pref-count">${item.count}</span>
              </a>
            </li>
          `;
        })
        .join("");
    }

    function getRangeLabelText() {
      return getRangeLabel();
    }

    function updateHeadlineMeta(items) {
      const rangeLabel = getRangeLabelText();
      const now = new Date();

      if (!items || items.length === 0) {
        totalCountEl.textContent = "0件";
        reportDateEl.textContent = rangeLabel;
        updateTimeEl.textContent = "-";
        return;
      }

      totalCountEl.textContent = `${items.length}件`;
      reportDateEl.textContent = rangeLabel;
      updateTimeEl.textContent = formatFullDateTime(now);
    }

    function buildDailySeries(incidents) {
      const buckets = [];
      const startMs = WEEKLY_RANGE.startUtcMs;
      for (let i = 0; i < RANGE_DAYS; i++) {
        const dayStart = startMs + i * DAY_SECONDS * 1000;
        const dayEnd = dayStart + DAY_SECONDS * 1000;
        buckets.push({
          label: formatHeadlineDate(new Date(dayStart)),
          start: dayStart,
          end: dayEnd,
          count: 0,
        });
      }

      incidents.forEach((item) => {
        const ts = Number(item.timestamp_second);
        if (!Number.isFinite(ts)) return;
        const tsMs = ts * 1000;
        const index = Math.floor((tsMs - startMs) / (DAY_SECONDS * 1000));
        if (index >= 0 && index < buckets.length) {
          buckets[index].count += 1;
        }
      });

      return buckets;
    }

    function renderTimeline(series) {
      if (!series || series.length === 0) {
        timelineEl.innerHTML = "";
        timelineStatusEl.textContent = "過去7日間のデータはありません。";
        return;
      }

      const maxCount = Math.max(...series.map((item) => item.count), 1);
      const niceMax = Math.max(Math.ceil(maxCount / 5) * 5, 1);
      const chartWidth = 680;
      const chartHeight = 240;
      const paddingX = 48;
      const paddingY = 24;
      const innerHeight = chartHeight - paddingY * 2;
      const step =
        series.length > 1
          ? (chartWidth - paddingX * 2) / (series.length - 1)
          : 0;

      const points = series.map((item, index) => {
        const x = paddingX + index * step;
        const ratio = Math.min(item.count / niceMax, 1);
        const y = paddingY + innerHeight - ratio * innerHeight;
        return { ...item, x, y };
      });

      const linePath = points
        .map((p, idx) => `${idx === 0 ? "M" : "L"}${p.x},${p.y}`)
        .join(" ");
      const baseY = paddingY + innerHeight;
      const areaPath = `${linePath} L${points[points.length - 1].x},${baseY} L${points[0].x},${baseY} Z`;

      const tickCount = 4;
      const gridLines = [];
      for (let i = 0; i <= tickCount; i++) {
        const value = Math.round((niceMax / tickCount) * i);
        const ratio = value / niceMax;
        const y = paddingY + innerHeight - ratio * innerHeight;
        gridLines.push(`
          <line class="grid-line" x1="${paddingX}" x2="${
          chartWidth - paddingX
        }" y1="${y}" y2="${y}" />
          <text class="grid-label" x="${paddingX - 10}" y="${
          y - 4
        }" text-anchor="end">${value}</text>
        `);
      }

      const dots = points
        .map(
          (p) => `
            <circle class="area-point" cx="${p.x}" cy="${p.y}" r="4">
              <title>${p.label}: ${p.count}件</title>
            </circle>`
        )
        .join("");

      const axisLabels = `
        <div class="axis-labels">
          ${points
            .map(
              (p, idx) =>
                `<span${
                  idx === 0 || idx === points.length - 1 ? "" : ' style="opacity:0.6"'
                }>${p.label}</span>`
            )
            .join("")}
        </div>
      `;

      timelineEl.innerHTML = `
        <svg viewBox="0 0 ${chartWidth} ${chartHeight}" preserveAspectRatio="none">
          <defs>
            <linearGradient id="timelineGradient" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stop-color="${"#0b1220"}" stop-opacity="0.75" />
              <stop offset="100%" stop-color="${"#0b1220"}" stop-opacity="0.05" />
            </linearGradient>
          </defs>
          ${gridLines.join("")}
          <path class="area-fill" d="${areaPath}" />
          <path class="area-line" d="${linePath}" />
          ${dots}
        </svg>
        ${axisLabels}
      `;

      const peak = series.reduce((prev, curr) =>
        curr.count > prev.count ? curr : prev
      );
      timelineStatusEl.textContent = `最多は${peak.label}の${peak.count}件（スケール上限 ${niceMax}件）`;
    }

    function isSameJstDay(timestampMs) {
      const todayMidnight = getJstMidnightUtcMs(new Date());
      const tomorrowMidnight = todayMidnight + DAY_SECONDS * 1000;
      return timestampMs >= todayMidnight && timestampMs < tomorrowMidnight;
    }

    async function loadCachedIncidents() {
      try {
        const cacheUrl = `${DATA_JSON_PATH}?t=${Date.now()}`;
        const res = await fetch(cacheUrl, { cache: "no-store" });
        if (!res.ok) return null;
        
        // 檢查文件修改時間是否為今天
        const lastModified = res.headers.get("Last-Modified");
        if (lastModified) {
          const fileModifiedTime = Date.parse(lastModified);
          if (!Number.isFinite(fileModifiedTime) || !isSameJstDay(fileModifiedTime)) {
            return null; // 文件不是今天更新的，返回 null 觸發 API 調用
          }
        } else {
          // 如果沒有 Last-Modified 頭，也返回 null 調用 API
          return null;
        }
        
        // 解析 JSON 數組
        const incidents = await res.json();
        if (!Array.isArray(incidents) || incidents.length === 0) {
          return null;
        }
        
        // 過濾掉 timestamp_second < created_after 的數據
        const afterSeconds = WEEKLY_RANGE.afterSeconds;
        return incidents.filter((item) => {
          const ts = Number(item.timestamp_second);
          return Number.isFinite(ts) && ts >= afterSeconds;
        });
      } catch (err) {
        console.warn("cached data.json load failed", err);
        return null;
      }
    }

    async function loadIncidents() {
      try {
        timelineStatusEl.textContent = "データを確認中…";
        let incidents = await loadCachedIncidents();
        let usedCache = false;

        if (incidents && incidents.length > 0) {
          usedCache = true;
          console.info("Using cached weekly data.json");
        } else {
          timelineStatusEl.textContent = "API からデータを取得しています…";
          const apiUrl = buildApiUrl();
          const res = await fetch(apiUrl);
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: データの取得に失敗しました`);
          }

          const afterSeconds = WEEKLY_RANGE.afterSeconds;
          incidents = (await res.json())
            .map((item) => ({
              ...item,
              prefecture:
                PREF_REMAP[item.prefecture?.toLowerCase()] ?? item.prefecture,
            }))
            .filter((item) => {
              const ts = Number(item.timestamp_second);
              return Number.isFinite(ts) && ts >= afterSeconds;
            });
        }

        if (!incidents || incidents.length === 0) {
          renderTimeline([]);
          renderPrefSummary([]);
          updateHeadlineMeta([]);
          timelineStatusEl.textContent =
            usedCache && incidents
              ? "キャッシュはありましたが、対象期間のデータはありません。"
              : "過去7日間のデータはありません。";
          return;
        }

        const dailySeries = buildDailySeries(incidents);
        renderTimeline(dailySeries);
        const summary = buildPrefSummary(incidents);
        renderPrefSummary(summary);
        updateHeadlineMeta(incidents);
      } catch (error) {
        console.error("failed to load incidents", error);
        timelineStatusEl.textContent = "データの取得に失敗しました。";
      }
    }

    loadIncidents();
  </script>
</body>
</html>
