<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/app_icon.png">
  <title>æ»‹è³€çœŒã‚¯ãƒå‡ºæ²¡ãƒãƒƒãƒ—ï½œæœ€æ–°ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æƒ…å ±</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="æ—¥æœ¬å…¨å›½ã®ã‚¯ãƒå‡ºæ²¡æƒ…å ±ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ç¢ºèªã§ãã‚‹ã‚¯ãƒå‡ºæ²¡ãƒãƒƒãƒ—ã€‚æœ€æ–°ã®ç›®æ’ƒæƒ…å ±ã‚„éƒ½é“åºœçœŒåˆ¥ã®å‡ºæ²¡çŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚"
  />

    <link rel="canonical" href="https://junlando.com/kumamap/shiga" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      --ink: #111827;
      --ink-soft: #4b5563;
      --accent: #b91c1c;
      --border: #e5e7eb;
      --bg: #fff;
      --bg-muted: #f9fafb;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", sans-serif;
      background: var(--bg);
      color: var(--ink);
      min-height: 100vh;
      line-height: 1.6;
    }

    a {
      color: inherit;
      text-decoration: none;
    }

    .page {
      max-width: 1024px;
      margin: 0 auto;
      padding: 32px 18px 64px;
    }

    header {
      border-bottom: 2px solid var(--border);
      padding-bottom: 18px;
      margin-bottom: 24px;
    }

    .headline {
      font-size: 32px;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .headline strong {
      color: var(--accent);
    }

    .meta-row {
      margin-top: 12px;
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
      font-size: 14px;
      color: var(--ink-soft);
    }

    .summary-strip {
      margin-top: 18px;
      padding: 12px 14px;
      background: var(--bg-muted);
      border-left: 4px solid var(--accent);
      font-size: 15px;
    }

    #total-count {
      font-weight: 700;
      font-size: 18px;
      color: var(--accent);
    }

    .report-content {
      display: flex;
      flex-direction: column;
      gap: 32px;
    }

    .map-block {
      border: 1px solid var(--border);
      background: #fff;
      padding: 18px;
    }

    #map {
      width: 100%;
      height: 420px;
    }

    #map-status {
      margin-top: 10px;
      font-size: 13px;
      color: var(--ink-soft);
    }

    .pref-summary {
      border: 1px solid var(--border);
      padding: 18px;
      background: #fff;
    }

    .pref-summary h2 {
      font-size: 18px;
      margin-bottom: 12px;
      border-left: 4px solid var(--accent);
      padding-left: 10px;
    }

    .pref-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 8px;
      list-style: none;
      font-size: 14px;
    }

    .pref-list li {
      padding: 8px 10px;
      border: 1px solid var(--border);
      background: var(--bg-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .pref-name {
      font-weight: 600;
    }

    .pref-count {
      color: var(--accent);
      font-weight: 700;
    }

    footer {
      margin-top: 40px;
      font-size: 12px;
      color: var(--ink-soft);
      text-align: right;
    }

    @media (max-width: 600px) {
      .headline {
        font-size: 26px;
      }

      #map {
        height: 320px;
      }
    }
  
    .timeline-chart {
      position: relative;
      width: 100%;
      padding: 12px 16px 20px;
      background: #f5f7fb;
      border-radius: 16px;
    }

    .timeline-chart svg {
      width: 100%;
      height: 260px;
    }

    .bar-rect {
      fill: #fcd7d7;
      stroke: none;
    }

    .bar-outline {
      fill: none;
      stroke: #e05858;
      stroke-width: 1.4;
    }

    .bar-value {
      font-size: 11px;
      fill: var(--ink);
      font-weight: 600;
    }

    .grid-line {
      stroke: rgba(15, 23, 42, 0.08);
      stroke-width: 1;
    }

    .grid-label {
      font-size: 11px;
      fill: var(--ink-soft);
    }

    .axis-labels {
      position: relative;
      width: 100%;
      height: 20px;
      font-size: 12px;
      color: var(--ink-soft);
      margin-top: 12px;
    }

    .axis-label-item {
      position: absolute;
      transform: translateX(-50%);
      text-align: center;
    }

    @media (max-width: 600px) {
      .bar-value {
        font-size: 14px;
      }

      .grid-label {
        font-size: 13px;
      }

      .axis-labels {
        font-size: 10px;
      }

      .timeline-chart {
        padding: 12px 8px 20px;
      }
    }

    .timeline-status {
      margin-top: 12px;
      font-size: 13px;
      color: var(--ink-soft);
    }
</style>
  <script type="module">
    // Import the functions you need from the SDKs you need
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";

    // TODO: Add SDKs for Firebase products that you want to use
    // https://firebase.google.com/docs/web/setup#available-libraries

    // Your web app's Firebase configuration
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
      apiKey: "AIzaSyDonsfxblXXS-AFv7sZDTSpX5dr7Z3GuFc",
      authDomain: "kumamapweb.firebaseapp.com",
      projectId: "kumamapweb",
      storageBucket: "kumamapweb.firebasestorage.app",
      messagingSenderId: "322213314578",
      appId: "1:322213314578:web:c859638e33cbb7313a18cb",
      measurementId: "G-4QPCVSXMQ7"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
  </script>
</head>

<body>
  <div class="page">
    <header>
      <div class="headline">ã€æ»‹è³€çœŒã€‘æœ€æ–°ã‚¯ãƒå‡ºæ²¡æƒ…å ±ã¨åœ°å›³<strong id="report-date"></strong></div>
      <div class="meta-row">
        <span>æ›´æ–°: <span id="update-time">-</span></span>
        <span>ãƒ‡ãƒ¼ã‚¿æä¾›: ã‚¯ãƒå‡ºæ²¡ãƒãƒƒãƒ—</span>
      </div>
      <div class="summary-strip">
        ç¾åœ¨ç¢ºèªã•ã‚Œã¦ã„ã‚‹å‡ºæ²¡ä»¶æ•° <span id="total-count">0ä»¶</span>
      </div>
    </header>

    <section class="report-content">
      <div class="map-block">
        <h2 style="font-size:18px;margin-bottom:12px;">å‡ºæ²¡åœ°ç‚¹ãƒãƒƒãƒ—</h2>
        <div id="map"></div>
        <div id="map-status">åœ°å›³ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
      </div>

      <div class="card">
        <h2>éå»7æ—¥é–“ã®å‡ºæ²¡ä»¶æ•°ã®æ¨ç§»</h2>
        <p class="subhead">éå»7æ—¥é–“ã®å‡ºæ²¡ä»¶æ•°æ¨ç§»</p>
        <div id="timeline-chart" class="timeline-chart" aria-live="polite"></div>
        <div id="timeline-status" class="timeline-status">ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆä¸­ã§ã™â€¦</div>
      </div>

      <div class="pref-summary"><h2>éƒ½é“åºœçœŒåˆ¥ã®å‡ºæ²¡çŠ¶æ³</h2>
        <ul id="prefecture-summary" class="pref-list">
          <li>ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­â€¦</li>
        </ul>
      </div>
    </section>

    <footer>
      éå…¬å¼ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚æ­£ç¢ºãªæƒ…å ±ã¯å„è‡ªæ²»ä½“ãƒ»è­¦å¯Ÿã®å…¬å¼ç™ºè¡¨ã‚’ã”ç¢ºèªãã ã•ã„ã€‚
    </footer>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ================================
    // å…¨åŸŸè®Šæ•¸
    // ================================
    let map;
    let markers = [];
    const mapStatusEl = document.getElementById("map-status");
    const prefSummaryEl = document.getElementById("prefecture-summary");
    const reportDateEl = document.getElementById("report-date");
    const updateTimeEl = document.getElementById("update-time");
    const totalCountEl = document.getElementById("total-count");
    const timelineEl = document.getElementById("timeline-chart");
    const timelineStatusEl = document.getElementById("timeline-status");
    // PLACES å°æ‡‰ï¼šAPI ä»£ç¢¼ â†’ é¡¯ç¤ºåç¨±
    const PREF_MAP = [
      { id: "hokkaido", name: "åŒ—æµ·é“" },
      { id: "aomori", name: "é’æ£®çœŒ" },
      { id: "iwate", name: "å²©æ‰‹çœŒ" },
      { id: "miyagi", name: "å®®åŸçœŒ" },
      { id: "akita", name: "ç§‹ç”°çœŒ" },
      { id: "yamagata", name: "å±±å½¢çœŒ" },
      { id: "fukushima", name: "ç¦å³¶çœŒ" },
      { id: "ibaraki", name: "èŒ¨åŸçœŒ" },
      { id: "tochigi", name: "æ ƒæœ¨çœŒ" },
      { id: "gunma", name: "ç¾¤é¦¬çœŒ" },
      { id: "saitama", name: "åŸ¼ç‰çœŒ" },
      { id: "chiba", name: "åƒè‘‰çœŒ" },
      { id: "tokyo", name: "æ±äº¬éƒ½" },
      { id: "kanagawa", name: "ç¥å¥ˆå·çœŒ" },
      { id: "niigata", name: "æ–°æ½ŸçœŒ" },
      { id: "toyama", name: "å¯Œå±±çœŒ" },
      { id: "ishikawa", name: "çŸ³å·çœŒ" },
      { id: "fukui", name: "ç¦äº•çœŒ" },
      { id: "yamanashi", name: "å±±æ¢¨çœŒ" },
      { id: "nagano", name: "é•·é‡çœŒ" },
      { id: "gifu", name: "å²é˜œçœŒ" },
      { id: "shizuoka", name: "é™å²¡çœŒ" },
      { id: "aichi", name: "æ„›çŸ¥çœŒ" },
      { id: "mie", name: "ä¸‰é‡çœŒ" },
      { id: "shiga", name: "æ»‹è³€çœŒ" },
      { id: "kyoto", name: "äº¬éƒ½åºœ" },
      { id: "osaka", name: "å¤§é˜ªåºœ" },
      { id: "hyogo", name: "å…µåº«çœŒ" },
      { id: "nara", name: "å¥ˆè‰¯çœŒ" },
      { id: "wakayama", name: "å’Œæ­Œå±±çœŒ" },
      { id: "tottori", name: "é³¥å–çœŒ" },
      { id: "shimane", name: "å³¶æ ¹çœŒ" },
      { id: "okayama", name: "å²¡å±±çœŒ" },
      { id: "hiroshima", name: "åºƒå³¶çœŒ" },
      { id: "yamaguchi", name: "å±±å£çœŒ" },
      { id: "tokushima", name: "å¾³å³¶çœŒ" },
      { id: "kagawa", name: "é¦™å·çœŒ" },
      { id: "ehime", name: "æ„›åª›çœŒ" },
      { id: "kochi", name: "é«˜çŸ¥çœŒ" },
      { id: "fukuoka", name: "ç¦å²¡çœŒ" },
      { id: "saga", name: "ä½è³€çœŒ" },
      { id: "nagasaki", name: "é•·å´çœŒ" },
      { id: "kumamoto", name: "ç†Šæœ¬çœŒ" },
      { id: "oita", name: "å¤§åˆ†çœŒ" },
      { id: "miyazaki", name: "å®®å´çœŒ" },
      { id: "kagoshima", name: "é¹¿å…å³¶çœŒ" },
      { id: "okinawa", name: "æ²–ç¸„çœŒ" },
    ];
    const PREF_ALIASES = {
      shimanetottori: "å³¶æ ¹çœŒ",
      narakizugawa: "äº¬éƒ½åºœ",
    };

    const PREF_REMAP = {
      shimanetottori: "shimane",
      narakizugawa: "kyoto",
    };
    const BLOCKED_PREFS = new Set(["yamanashi"]);



    const TARGET_PREF = "shiga";

    // ================================
    // è‡ªå®šç¾© Marker åœ–æ¨™
    // ================================
    // åœ–æ¨™é…ç½®ï¼šå¯ä»¥ä¿®æ”¹é€™äº›åƒæ•¸ä¾†ä½¿ç”¨ä½ çš„è‡ªå®šç¾©åœ–ç‰‡
    const ICON_CONFIG = {
      // é¸é … 1: ä½¿ç”¨åœ–ç‰‡æ–‡ä»¶ï¼ˆæ¨è–¦ï¼‰
      // å°‡ä½ çš„åœ–æ¨™åœ–ç‰‡æ”¾åœ¨ kumamap/ ç›®éŒ„ä¸‹ï¼Œç„¶å¾Œä¿®æ”¹ä¸‹é¢çš„è·¯å¾‘
      useImageIcon: true, // ä½¿ç”¨åœ–ç‰‡åœ–æ¨™
      imageIconUrl: '/kumamap/kuma_marker.png', // ä½ çš„åœ–æ¨™åœ–ç‰‡è·¯å¾‘
      imageIconSize: [45, 45], // åœ–æ¨™å¤§å° [å¯¬åº¦, é«˜åº¦]
      
      // é¸é … 2: ä½¿ç”¨ CSS/HTML è‡ªå®šç¾©åœ–æ¨™ï¼ˆå‚™ç”¨ï¼‰
      useCustomDivIcon: false, // ä¸ä½¿ç”¨ div åœ–æ¨™
    };

    // å‰µå»ºåœ–ç‰‡åœ–æ¨™ï¼ˆå¦‚æœä½¿ç”¨ï¼‰
    let customImageIcon = null;
    if (ICON_CONFIG.useImageIcon) {
      customImageIcon = L.icon({
        iconUrl: ICON_CONFIG.imageIconUrl,
        iconSize: ICON_CONFIG.imageIconSize,
        iconAnchor: [ICON_CONFIG.imageIconSize[0] / 2, ICON_CONFIG.imageIconSize[1]], // åœ–æ¨™åº•éƒ¨ä¸­å¿ƒé»
        popupAnchor: [0, -ICON_CONFIG.imageIconSize[1]], // Popup ä½ç½®
      });
    }

    // å‰µå»ºè‡ªå®šç¾© div åœ–æ¨™ï¼ˆç†Šåœ–æ¨™æ¨£å¼ï¼‰
    const customDivIcon = L.divIcon({
      className: 'custom-marker-icon',
      html: '<div style="background-color: #f97316; width: 30px; height: 30px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"><span style="color: white; font-size: 20px; transform: rotate(45deg); display: block; text-align: center; line-height: 24px;">ğŸ»</span></div>',
      iconSize: [30, 30],
      iconAnchor: [15, 30],
      popupAnchor: [0, -30]
    });

    // æ±ºå®šä½¿ç”¨å“ªå€‹åœ–æ¨™
    const markerIcon = ICON_CONFIG.useImageIcon && customImageIcon 
      ? customImageIcon 
      : customDivIcon;

    // ================================
    // æ™‚é–“ãƒ»API é–¢é€£
    // ================================
    const JST_OFFSET_MS = 9 * 60 * 60 * 1000;
    const RANGE_DAYS = 7;
    const DAY_SECONDS = 24 * 60 * 60;

    const API_BASE = "https://kumamap.junlando.com/incidents/";

    function getAfterSeconds() {
      // ä»Šå¤©çš„æ—¥æœ¬æ—¶é—´ 0ç‚¹
      const now = new Date();
      const jstNow = new Date(now.getTime() + JST_OFFSET_MS);
      const year = jstNow.getUTCFullYear();
      const month = jstNow.getUTCMonth();
      const day = jstNow.getUTCDate();
      const midnightUtcMs = Date.UTC(year, month, day) - JST_OFFSET_MS;
      return Math.floor(midnightUtcMs / 1000);
    }

    function getBeforeSeconds() {
      // ä»Šå¤©çš„æ—¥æœ¬æ—¶é—´ 24ç‚¹ï¼ˆæ˜å¤©çš„0ç‚¹ï¼‰
      const now = new Date();
      const jstNow = new Date(now.getTime() + JST_OFFSET_MS);
      const year = jstNow.getUTCFullYear();
      const month = jstNow.getUTCMonth();
      const day = jstNow.getUTCDate();
      const tomorrowMidnightUtcMs = Date.UTC(year, month, day + 1) - JST_OFFSET_MS;
      return Math.floor(tomorrowMidnightUtcMs / 1000);
    }

    function buildApiUrl() {
      // ä»Šå¤©çš„æ—¥æœ¬æ—¶é—´ 0ç‚¹ï½24ç‚¹
      const afterSeconds = getAfterSeconds();
      const beforeSeconds = getBeforeSeconds();
      const query = new URLSearchParams();
      query.set("created_after", afterSeconds);
      query.set("created_before", beforeSeconds);
      const queryString = query.toString();
      return `${API_BASE}?${queryString}`;
    }


    // ================================
    // åœ°åœ–åˆå§‹åŒ–
    // ================================
    function initMap() {
      // åˆå§‹åŒ–åœ°åœ–ï¼ˆä¸­å¿ƒæ”¾åœ¨æ„›çŸ¥çœŒï¼‰
      map = L.map("map").setView([35.18028, 136.90667], 8.4);

      // åŠ å…¥ OpenStreetMap åœ–ç£š
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "Â© OpenStreetMap contributors",
        maxZoom: 18,
      }).addTo(map);

      // è¼‰å…¥ incidents
      loadIncidents();
    }

    // ================================
    // æ—¶é—´ãƒ»é›†è¨ˆé–¢é€£ Helper
    // ================================
    // å¾ Unix æ™‚é–“æˆ³ï¼ˆç§’ï¼‰è§£æç‚º Date å°è±¡
    function parseTimestamp(tsSeconds) {
      if (!tsSeconds) return null;
      const num = Number(tsSeconds);
      if (!Number.isFinite(num)) return null;
      const d = new Date(num * 1000); // è½‰æ›ç‚ºæ¯«ç§’
      return isNaN(d.getTime()) ? null : d;
    }

    function formatHeadlineDate(date) {
      if (!date) return "-";
      // date å°è±¡æ˜¯å¾ afterSeconds å‰µå»ºçš„ï¼ŒafterSeconds æ˜¯æ—¥æœ¬æ™‚é–“ 0 é»çš„ UTC æ™‚é–“æˆ³
      // è¦ç²å–æ—¥æœ¬æ™‚é–“çš„æ—¥æœŸï¼Œéœ€è¦å¾ UTC æ™‚é–“è¨ˆç®—
      // date.getTime() è¿”å›çš„æ˜¯ UTC æ™‚é–“çš„æ¯«ç§’æ•¸
      // åŠ ä¸Š JST_OFFSET_MS å¾Œï¼Œä½¿ç”¨ UTC æ–¹æ³•ç²å–æ—¥æœ¬æ™‚é–“çš„æ—¥æœŸ
      const utcMs = date.getTime();
      const jstMs = utcMs + JST_OFFSET_MS;
      const jstDate = new Date(jstMs);
      // ä½¿ç”¨ UTC æ–¹æ³•ç²å–æ—¥æœ¬æ™‚é–“çš„æ—¥æœŸ
      const m = jstDate.getUTCMonth() + 1;
      const d = jstDate.getUTCDate();
      return `${m}æœˆ${d}æ—¥`;
    }

    function formatFullDateTime(date) {
      if (!date) return "-";
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const dd = String(date.getDate()).padStart(2, "0");
      const hh = String(date.getHours()).padStart(2, "0");
      const mi = String(date.getMinutes()).padStart(2, "0");
      return `${yyyy}/${mm}/${dd} ${hh}:${mi}`;
    }

    function formatDateForMobile(date, isLast = false) {
      if (!date) return "-";
      const utcMs = date.getTime();
      const jstMs = utcMs + JST_OFFSET_MS;
      const jstDate = new Date(jstMs);
      const d = jstDate.getUTCDate();
      if (isLast) {
        return `${d}æ—¥`;
      }
      const m = jstDate.getUTCMonth() + 1;
      return `${m}æœˆ${d}æ—¥`;
    }
    }

    // å¾ Unix æ™‚é–“æˆ³ï¼ˆç§’ï¼‰æ ¼å¼åŒ–ç‚ºæ—¥æœŸæ™‚é–“å­—ç¬¦ä¸²
    function formatTimestampSecond(tsSeconds) {
      if (!tsSeconds) return "ä¸æ˜";
      const date = parseTimestamp(tsSeconds);
      if (!date) return "ä¸æ˜";
      return formatFullDateTime(date);
    }

    function getPrefName(prefId) {
      const normalized = (prefId || "").toLowerCase();
      if (PREF_ALIASES[normalized]) {
        return PREF_ALIASES[normalized];
      }
      return (
        PREF_MAP.find((p) => p.id === normalized)?.name ||
        prefId ||
        "ä¸æ˜"
      );
    }

    function getHeadlineDateFromParams() {
      // ä½¿ç”¨ä»Šå¤©çš„æ—¥æœ¬æ—¶é—´
      const now = new Date();
      return new Date(now.getTime() + JST_OFFSET_MS);
    }

    
    function getJstMidnightUtcMs(date) {
      const jstDate = new Date(date.getTime() + JST_OFFSET_MS);
      const year = jstDate.getUTCFullYear();
      const month = jstDate.getUTCMonth();
      const dom = jstDate.getUTCDate();
      return Date.UTC(year, month, dom) - JST_OFFSET_MS;
    }

    function getWeeklyRange() {
      // åŠ¨æ€è®¡ç®—è¿‡å»7å¤©çš„èŒƒå›´ï¼ˆæ—¥æœ¬æ—¶é—´ï¼‰
      const now = new Date();
      const todayMidnight = getJstMidnightUtcMs(now);
      const startMidnight = todayMidnight - (RANGE_DAYS - 1) * DAY_SECONDS * 1000;
      const endMidnight = todayMidnight + DAY_SECONDS * 1000;
      
      const afterSeconds = Math.floor(startMidnight / 1000);
      const beforeSeconds = Math.floor(endMidnight / 1000);
      
      return {
        afterSeconds,
        beforeSeconds,
        startUtcMs: startMidnight,
        endUtcMs: endMidnight,
      };
    }
function buildPrefSummary(items) {
      const counts = new Map();
      items.forEach((item) => {
        const id = (item.prefecture || "").toLowerCase();
        const name = getPrefName(id);
        counts.set(id, { id, name, count: (counts.get(id)?.count || 0) + 1 });
      });
      return Array.from(counts.values()).sort(
        (a, b) => b.count - a.count || a.name.localeCompare(b.name)
      );
    }

    
    function buildDailySeries(incidents) {
      const range = getWeeklyRange();
      const buckets = [];
      const startMs = range.startUtcMs;
      for (let i = 0; i < RANGE_DAYS; i++) {
        const dayStart = startMs + i * DAY_SECONDS * 1000;
        const dayEnd = dayStart + DAY_SECONDS * 1000;
        buckets.push({
          label: formatHeadlineDate(new Date(dayStart)),
          start: dayStart,
          end: dayEnd,
          count: 0,
        });
      }

      incidents.forEach((item) => {
        const ts = Number(item.timestamp_second);
        if (!Number.isFinite(ts)) return;
        const tsMs = ts * 1000;
        const index = Math.floor((tsMs - startMs) / (DAY_SECONDS * 1000));
        if (index >= 0 && index < buckets.length) {
          buckets[index].count += 1;
        }
      });

      return buckets;
    }

    function renderTimeline(series) {
      if (!series || series.length === 0) {
        timelineEl.innerHTML = "";
        timelineStatusEl.textContent = "éå»7æ—¥é–“ã®ãƒ‡ãƒ¼ã‚¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚";
        return;
      }

      const maxCount = Math.max(...series.map((item) => item.count), 1);
      const niceMax = Math.max(Math.ceil(maxCount / 5) * 5, 1);
      const isMobile = window.innerWidth <= 600;
      const chartWidth = isMobile ? 360 : 680;
      const chartHeight = 240;
      const paddingX = isMobile ? 36 : 48;
      const paddingY = 24;
      const innerHeight = chartHeight - paddingY * 2;
      const step = (chartWidth - paddingX * 2) / series.length;
      const barWidthRatio = isMobile ? 1.2 : 0.6;
      const barWidth = Math.min(20, Math.max(step * barWidthRatio, isMobile ? 14 : 8));

      const tickCount = 4;
      const gridLines = [];
      for (let i = 0; i <= tickCount; i++) {
        const value = Math.round((niceMax / tickCount) * i);
        const ratio = value / niceMax;
        const y = paddingY + innerHeight - ratio * innerHeight;
        gridLines.push(`
          <line class="grid-line" x1="${paddingX}" x2="${
          chartWidth - paddingX
        }" y1="${y}" y2="${y}" />
          <text class="grid-label" x="${paddingX - 10}" y="${
          y - 4
        }" text-anchor="end">${value}</text>
        `);
      }

      const bars = series
        .map((item, index) => {
          const ratio = Math.min(item.count / niceMax, 1);
          const barHeight = ratio * innerHeight;
          const x = paddingX + index * step + (step - barWidth) / 2;
          const y = paddingY + innerHeight - barHeight;
          return { ...item, x, y, barHeight };
        })
        .map(
          (bar) => `
            <g>
              <rect class="bar-rect" x="${bar.x}" y="${bar.y}" width="${barWidth}" height="${bar.barHeight}" rx="6"></rect>
              <rect class="bar-outline" x="${bar.x}" y="${bar.y}" width="${barWidth}" height="${bar.barHeight}" rx="6"></rect>
              <text class="bar-value" x="${bar.x + barWidth / 2}" y="${bar.y - 6}" text-anchor="middle">${bar.count}</text>
            </g>
          `
        )
        .join("");

      // åœ¨æ‰‹æ©Ÿä¸Šåªé¡¯ç¤ºé ­å°¾æ—¥æœŸ
      const axisLabels = `
        <div class="axis-labels">
          ${series
            .map((item, idx) => {
              const barCenterX = paddingX + idx * step + step / 2;
              const percentLeft = (barCenterX / chartWidth) * 100;
              const shouldShow = !isMobile || idx === 0 || idx === series.length - 1;
              if (!shouldShow) return "";
              // åœ¨æ‰‹æ©Ÿä¸Šï¼Œæœ€å¾Œä¸€å¤©åªé¡¯ç¤ºæ—¥æœŸ
              const displayLabel = isMobile && idx === series.length - 1
                ? formatDateForMobile(new Date(item.start), true)
                : item.label;
              return `<span class="axis-label-item" style="left: ${percentLeft}%; opacity:1">${displayLabel}</span>`;
            })
            .join("")}
        </div>
      `;

      timelineEl.innerHTML = `
        <svg viewBox="0 0 ${chartWidth} ${chartHeight}" preserveAspectRatio="none">
          ${gridLines.join("")}
          ${bars}
        </svg>
        ${axisLabels}
      `;

      const peak = series.reduce((prev, curr) =>
        curr.count > prev.count ? curr : prev
      );
      timelineStatusEl.textContent = `æœ€å¤šã¯${peak.label}ã®${peak.count}ä»¶ã§ã—ãŸ`;
    }

    function renderPrefSummary(summary) {
      if (!summary || summary.length === 0) {
        prefSummaryEl.innerHTML =
          "<li>ç¾åœ¨è¡¨ç¤ºã§ãã‚‹å‡ºæ²¡æƒ…å ±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>";
        return;
      }
      prefSummaryEl.innerHTML = summary
        .map((item) => {
          const targetPath = `https://junlando.com/kumamap/${item.id}/`;
          const url = targetPath;
          return `
            <li>
              <a class="pref-link" href="${url}">
                <span class="pref-name">${item.name}</span>
                <span class="pref-count">${item.count}</span>
              </a>
            </li>
          `;
        })
        .join("");
    }


    function updateHeadlineMeta(items) {
      const headlineDate = getHeadlineDateFromParams();
      const now = new Date();

      if (!items || items.length === 0) {
        if (totalCountEl) totalCountEl.textContent = "0ä»¶";
        if (reportDateEl) reportDateEl.textContent = `${formatHeadlineDate(headlineDate)}`;
        if (updateTimeEl) updateTimeEl.textContent = "-";
        return;
      }

      if (totalCountEl) totalCountEl.textContent = `${items.length}ä»¶`;
      if (reportDateEl) reportDateEl.textContent = `${formatHeadlineDate(headlineDate)}`;
      if (updateTimeEl) updateTimeEl.textContent = formatFullDateTime(now);
    }

    // ================================
    // å–å¾—è³‡æ–™ä¸¦é¡¯ç¤º markers
    // ================================
    async function loadIncidents() {
      try {
        mapStatusEl.textContent = `åœ°å›³ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­â€¦`;
        
        const apiUrl = buildApiUrl();
        const res = await fetch(apiUrl);
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: API ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ`);
        }
        
        const incidents = (await res.json())
          .map((item) => ({
            ...item,
            prefecture: PREF_REMAP[item.prefecture?.toLowerCase()] ?? item.prefecture,
          }))
                    .filter((item) => {
            const pref = (item.prefecture || "").toLowerCase();
            return !BLOCKED_PREFS.has(pref);
          })
          .filter((item) => {
            // éæ¿¾æ‰ timestamp_second ç™¼ç”Ÿåœ¨æ˜¨å¤©çš„ incidents
            const afterSeconds = getAfterSeconds();
            const ts = item.timestamp_second;
            if (!ts) return false; // æ²’æœ‰æ™‚é–“æˆ³çš„ä¹Ÿéæ¿¾æ‰
            return ts >= afterSeconds; // åªä¿ç•™ä»Šå¤©åŠä¹‹å¾Œçš„
          });
        const filteredAll = incidents;
        const filteredIncidents = filteredAll.filter(
          (item) => (item.prefecture || "").toLowerCase() === TARGET_PREF
        );

        // æ¸…é™¤ç¾æœ‰çš„ markers
        markers.forEach((marker) => {
          map.removeLayer(marker);
        });
        markers = [];

        // å³ä½¿è©²ç¸£å¸‚æ²’æœ‰æ•¸æ“šï¼Œä¹Ÿè¦é¡¯ç¤ºå…¨åœ‹çµ±è¨ˆ
        const summary = buildPrefSummary(filteredAll);
        renderPrefSummary(summary);

        if (!filteredIncidents || filteredIncidents.length === 0) {
          mapStatusEl.textContent = `è¡¨ç¤ºã§ãã‚‹å‡ºæ²’æƒ…å ±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`;
          updateHeadlineMeta([]);
          return;
        }

        const bounds = [];
        filteredIncidents.forEach((item) => {
          const lat = parseFloat(item.latitude);
          const lng = parseFloat(item.longitude);

          if (isNaN(lat) || isNaN(lng) || !lat || !lng) {
            console.warn("Invalid coordinates:", item);
            return;
          }

          // å°æ•¸é»4ä½
          const latStr = lat.toFixed(4);
          const lngStr = lng.toFixed(4);

          // å–å¾—éƒ½é“åºœçœŒåç¨±
          const prefName = getPrefName(item.prefecture);
          
          // æ ¼å¼åŒ–æ™‚é–“ï¼ˆä½¿ç”¨ timestamp_secondï¼‰
          const timeStr = formatTimestampSecond(item.timestamp_second);
          
          // å»ºç«‹ popup å…§å®¹
          let desc = `<strong>${prefName}</strong><br>`;
          desc += `ç·¯åº¦: ${latStr}<br>çµŒåº¦: ${lngStr}<br>æ™‚é–“: ${timeStr}`;
          if (item.description) {
            const shortDesc = item.description.length > 100 
              ? item.description.substring(0, 100) + "..." 
              : item.description;
            desc += `<br><br>${shortDesc}`;
          }

          // ä½¿ç”¨è‡ªå®šç¾©åœ–æ¨™å‰µå»º marker
          const marker = L.marker([lat, lng], {
            icon: markerIcon // ä½¿ç”¨é…ç½®çš„åœ–æ¨™ï¼ˆkuma_marker.pngï¼‰
          })
            .addTo(map)
            .bindPopup(desc);

          markers.push(marker);
          bounds.push([lat, lng]);
        });

        updateHeadlineMeta(filteredIncidents);// å¦‚æœæœ‰ markersï¼Œèª¿æ•´åœ°åœ–è¦–è§’
        if (bounds.length > 0) {
          const group = new L.featureGroup(markers);
          map.fitBounds(group.getBounds(), { padding: [30, 30] });
          mapStatusEl.textContent = `å‡ºæ²¡æƒ…å ± ${bounds.length} ä»¶ã‚’è¡¨ç¤ºä¸­`;
        } else {
          mapStatusEl.textContent = `è¡¨ç¤ºã§ãã‚‹å‡ºæ²¡æƒ…å ±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`;
        }
      } catch (e) {
        console.error("failed to load incidents", e);
        mapStatusEl.textContent = "ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚";
        mapStatusEl.className = "error";
      }
    }

    // ================================
    // åˆå§‹åŒ–
    // ================================
    function waitForLeaflet() {
      if (typeof L !== "undefined") {
        initMap();
      } else {
        setTimeout(waitForLeaflet, 100);
      }
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", waitForLeaflet);
    } else {
      waitForLeaflet();
    }
  </script>
</body>
</html>